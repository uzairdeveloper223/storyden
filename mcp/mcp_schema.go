// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package mcp

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type CategoryItem struct {
	// Category description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Category name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Category slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CategoryItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CategoryItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in CategoryItem: required")
	}
	type Plain CategoryItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CategoryItem(plain)
	return nil
}

type DatagraphItemKindYaml string

const DatagraphItemKindYamlCollection DatagraphItemKindYaml = "collection"
const DatagraphItemKindYamlEvent DatagraphItemKindYaml = "event"
const DatagraphItemKindYamlNode DatagraphItemKindYaml = "node"
const DatagraphItemKindYamlPost DatagraphItemKindYaml = "post"
const DatagraphItemKindYamlProfile DatagraphItemKindYaml = "profile"
const DatagraphItemKindYamlReply DatagraphItemKindYaml = "reply"
const DatagraphItemKindYamlThread DatagraphItemKindYaml = "thread"

var enumValues_DatagraphItemKindYaml = []interface{}{
	"post",
	"thread",
	"reply",
	"node",
	"collection",
	"profile",
	"event",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatagraphItemKindYaml) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatagraphItemKindYaml {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatagraphItemKindYaml, v)
	}
	*j = DatagraphItemKindYaml(v)
	return nil
}

type DatagraphItemRef struct {
	// Unique identifier of the datagraph item
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type of datagraph item (thread, node, profile, collection, etc.)
	Kind DatagraphItemKindYaml `json:"kind" yaml:"kind" mapstructure:"kind"`

	// URL-friendly slug of the datagraph item
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatagraphItemRef) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DatagraphItemRef: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in DatagraphItemRef: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in DatagraphItemRef: required")
	}
	type Plain DatagraphItemRef
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DatagraphItemRef(plain)
	return nil
}

type LibraryPageSearchItem struct {
	// Page content excerpt
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Brief description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Page name/title
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL-friendly identifier
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LibraryPageSearchItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in LibraryPageSearchItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in LibraryPageSearchItem: required")
	}
	type Plain LibraryPageSearchItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LibraryPageSearchItem(plain)
	return nil
}

type LibraryPageTreeNode struct {
	// Brief description of the page
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Display name of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Slug of the parent page (omitted for root pages)
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// URL-friendly identifier for the page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags associated with this page
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LibraryPageTreeNode) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in LibraryPageTreeNode: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in LibraryPageTreeNode: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in LibraryPageTreeNode: required")
	}
	type Plain LibraryPageTreeNode
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LibraryPageTreeNode(plain)
	return nil
}

type RobotChatContext struct {
	// Optional reference to a datagraph item if the user is viewing one (e.g., a
	// thread, library page, profile)
	DatagraphItem *DatagraphItemRef `json:"datagraph_item,omitempty" yaml:"datagraph_item,omitempty" mapstructure:"datagraph_item,omitempty"`

	// Human-readable page type if not viewing a specific datagraph item. Examples:
	// 'Index page', 'Settings page', 'Admin page', 'Search page'. This is free-form
	// text since the backend doesn't know about frontend routes.
	PageType *string `json:"page_type,omitempty" yaml:"page_type,omitempty" mapstructure:"page_type,omitempty"`
}

type RobotItem struct {
	// Human-readable description of the Robot's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Unique identifier
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Robot name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RobotItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in RobotItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RobotItem: required")
	}
	type Plain RobotItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RobotItem(plain)
	return nil
}

type SearchedItem struct {
	// Brief description or excerpt
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Unique identifier
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type of content
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Title or name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL friendly identifier
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SearchedItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SearchedItem: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in SearchedItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SearchedItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in SearchedItem: required")
	}
	type Plain SearchedItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SearchedItem(plain)
	return nil
}

type TagItem struct {
	// Number of items tagged with this tag
	ItemCount int `json:"item_count" yaml:"item_count" mapstructure:"item_count"`

	// The tag name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TagItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item_count"]; raw != nil && !ok {
		return fmt.Errorf("field item_count in TagItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in TagItem: required")
	}
	type Plain TagItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TagItem(plain)
	return nil
}

type ThreadSummary struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Category name
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Short excerpt of the thread
	Excerpt string `json:"excerpt" yaml:"excerpt" mapstructure:"excerpt"`

	// Slug corresponds to the JSON schema field "slug".
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreadSummary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ThreadSummary: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ThreadSummary: required")
	}
	if _, ok := raw["excerpt"]; raw != nil && !ok {
		return fmt.Errorf("field excerpt in ThreadSummary: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ThreadSummary: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ThreadSummary: required")
	}
	type Plain ThreadSummary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ThreadSummary(plain)
	return nil
}

// List all thread categories with their names and descriptions
type ToolCategoryList struct {
	// Input corresponds to the JSON schema field "input".
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolCategoryListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolCategoryListOutput struct {
	// Categories corresponds to the JSON schema field "categories".
	Categories []CategoryItem `json:"categories" yaml:"categories" mapstructure:"categories"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolCategoryListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["categories"]; raw != nil && !ok {
		return fmt.Errorf("field categories in ToolCategoryListOutput: required")
	}
	type Plain ToolCategoryListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolCategoryListOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolCategoryList) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolCategoryList: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolCategoryList: required")
	}
	type Plain ToolCategoryList
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolCategoryList(plain)
	return nil
}

type ToolInfo struct {
	// Brief description of what the tool does
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The tool name identifier
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ToolInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolInfo: required")
	}
	type Plain ToolInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolInfo(plain)
	return nil
}

// Create a new page in the library. A slug will be generated automatically if not
// provided.
type ToolLibraryPageCreate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLibraryPageCreateInput struct {
	// The content of the page in HTML format
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// The name/title of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Slug of the parent page. Only include if you already have a parent slug
	// available. Leave empty to create a root-level page.
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// The unique slug for this page. If not provided, one will be generated from the
	// name.
	Slug *string `json:"slug,omitempty" yaml:"slug,omitempty" mapstructure:"slug,omitempty"`

	// Optional external URL if this page references a topic on another website
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Visibility of the page (default: published)
	Visibility *ToolLibraryPageCreateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolLibraryPageCreateInputVisibility string

const ToolLibraryPageCreateInputVisibilityDraft ToolLibraryPageCreateInputVisibility = "draft"
const ToolLibraryPageCreateInputVisibilityPublished ToolLibraryPageCreateInputVisibility = "published"

var enumValues_ToolLibraryPageCreateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolLibraryPageCreateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolLibraryPageCreateInputVisibility, v)
	}
	*j = ToolLibraryPageCreateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageCreateInput: required")
	}
	type Plain ToolLibraryPageCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = ToolLibraryPageCreateInput(plain)
	return nil
}

type ToolLibraryPageCreateOutput struct {
	// The name of the created page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The slug of the created page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageCreateOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageCreateOutput: required")
	}
	type Plain ToolLibraryPageCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageCreateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageCreate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageCreate: required")
	}
	type Plain ToolLibraryPageCreate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageCreate(plain)
	return nil
}

// Get detailed information about a specific library page by its slug.
type ToolLibraryPageGet struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLibraryPageGetInput struct {
	// The unique identifier of the library page to retrieve
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPageGetInput: required")
	}
	type Plain ToolLibraryPageGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolLibraryPageGetInput(plain)
	return nil
}

type ToolLibraryPageGetOutput struct {
	// Slugs of child pages
	ChildPages []string `json:"child_pages" yaml:"child_pages" mapstructure:"child_pages"`

	// Brief description of the page
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Display name of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL-friendly identifier for the page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags associated with this page
	Tags []string `json:"tags" yaml:"tags" mapstructure:"tags"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["child_pages"]; raw != nil && !ok {
		return fmt.Errorf("field child_pages in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolLibraryPageGetOutput: required")
	}
	type Plain ToolLibraryPageGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageGetOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGet) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageGet: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageGet: required")
	}
	type Plain ToolLibraryPageGet
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageGet(plain)
	return nil
}

// Search for pages in the library wiki. Returns matching pages based on the search
// query.
type ToolLibraryPageSearch struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageSearchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageSearchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLibraryPageSearchInput struct {
	// The search query text
	Query string `json:"query" yaml:"query" mapstructure:"query"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageSearchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in ToolLibraryPageSearchInput: required")
	}
	type Plain ToolLibraryPageSearchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Query) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "query", 1)
	}
	*j = ToolLibraryPageSearchInput(plain)
	return nil
}

type ToolLibraryPageSearchOutput struct {
	// List of matching library pages
	Items []LibraryPageSearchItem `json:"items" yaml:"items" mapstructure:"items"`

	// Total number of results found
	Results int `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageSearchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in ToolLibraryPageSearchOutput: required")
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in ToolLibraryPageSearchOutput: required")
	}
	type Plain ToolLibraryPageSearchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageSearchOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageSearch) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageSearch: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageSearch: required")
	}
	type Plain ToolLibraryPageSearch
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageSearch(plain)
	return nil
}

// Get the full tree structure of pages in the library. Returns a hierarchical view
// of all wiki pages showing their parent-child relationships.
type ToolLibraryPageTree struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageTreeInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageTreeOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLibraryPageTreeInput struct {
	// Maximum depth to traverse (-1 for unlimited, 0 for root only, 1 for root +
	// children, etc.)
	Depth *int `json:"depth,omitempty" yaml:"depth,omitempty" mapstructure:"depth,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageTreeInput) UnmarshalJSON(value []byte) error {
	type Plain ToolLibraryPageTreeInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Depth != nil && -1 > *plain.Depth {
		return fmt.Errorf("field %s: must be >= %v", "depth", -1)
	}
	*j = ToolLibraryPageTreeInput(plain)
	return nil
}

type ToolLibraryPageTreeOutput struct {
	// List of pages in tree structure
	Pages []LibraryPageTreeNode `json:"pages" yaml:"pages" mapstructure:"pages"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageTreeOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["pages"]; raw != nil && !ok {
		return fmt.Errorf("field pages in ToolLibraryPageTreeOutput: required")
	}
	type Plain ToolLibraryPageTreeOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageTreeOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageTree) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageTree: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageTree: required")
	}
	type Plain ToolLibraryPageTree
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageTree(plain)
	return nil
}

// Update an existing page in the library. Only provide the fields you want to
// change.
type ToolLibraryPageUpdate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLibraryPageUpdateInput struct {
	// The new content of the page in HTML format
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// The unique identifier of the page to update
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The new name/title of the page
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// New parent page slug. Provide to move the page to a different parent.
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// New external URL reference
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// New visibility of the page
	Visibility *ToolLibraryPageUpdateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolLibraryPageUpdateInputVisibility string

const ToolLibraryPageUpdateInputVisibilityDraft ToolLibraryPageUpdateInputVisibility = "draft"
const ToolLibraryPageUpdateInputVisibilityPublished ToolLibraryPageUpdateInputVisibility = "published"

var enumValues_ToolLibraryPageUpdateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolLibraryPageUpdateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolLibraryPageUpdateInputVisibility, v)
	}
	*j = ToolLibraryPageUpdateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPageUpdateInput: required")
	}
	type Plain ToolLibraryPageUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.Name != nil && len(*plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = ToolLibraryPageUpdateInput(plain)
	return nil
}

type ToolLibraryPageUpdateOutput struct {
	// The name of the updated page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The slug of the updated page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageUpdateOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageUpdateOutput: required")
	}
	type Plain ToolLibraryPageUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageUpdateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageUpdate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageUpdate: required")
	}
	type Plain ToolLibraryPageUpdate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageUpdate(plain)
	return nil
}

// Create or update a link in the shared bookmarks list. Fetches the URL and
// extracts OpenGraph metadata (title, description) and plain text content. Useful
// for bookmarking websites, articles, or any web content.
type ToolLinkCreate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLinkCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLinkCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolLinkCreateInput struct {
	// The URL to create a bookmark for. Must be a valid HTTP/HTTPS URL.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in ToolLinkCreateInput: required")
	}
	type Plain ToolLinkCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreateInput(plain)
	return nil
}

type ToolLinkCreateOutput struct {
	// Description extracted from OpenGraph metadata
	OpengraphDescription *string `json:"opengraph_description,omitempty" yaml:"opengraph_description,omitempty" mapstructure:"opengraph_description,omitempty"`

	// Title extracted from OpenGraph metadata
	OpengraphTitle *string `json:"opengraph_title,omitempty" yaml:"opengraph_title,omitempty" mapstructure:"opengraph_title,omitempty"`

	// Plain text content extracted from the page
	PlainText *string `json:"plain_text,omitempty" yaml:"plain_text,omitempty" mapstructure:"plain_text,omitempty"`

	// Unique identifier for the link
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// The bookmarked URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLinkCreateOutput: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in ToolLinkCreateOutput: required")
	}
	type Plain ToolLinkCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLinkCreate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLinkCreate: required")
	}
	type Plain ToolLinkCreate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreate(plain)
	return nil
}

// Create a new Robot (agent) with a specific purpose and behavior. Robots are
// customizable automations that can help users with specific workflows using
// tailored tools and instructions.
type ToolRobotCreate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolRobotCreateInput struct {
	// Optional human-readable description of the Robot's purpose and capabilities
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The name of the Robot - should be descriptive and help identify its purpose
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The directive/system prompt that defines how the Robot behaves, what it helps
	// with, and its personality. This is the primary instruction that guides the
	// Robot's behavior.
	Playbook string `json:"playbook" yaml:"playbook" mapstructure:"playbook"`

	// List of tool names that the Robot can use.
	Tools []string `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ToolRobotCreateInput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotCreateInput: required")
	}
	if _, ok := raw["playbook"]; raw != nil && !ok {
		return fmt.Errorf("field playbook in ToolRobotCreateInput: required")
	}
	type Plain ToolRobotCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Playbook) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "playbook", 1)
	}
	*j = ToolRobotCreateInput(plain)
	return nil
}

type ToolRobotCreateOutput struct {
	// The unique identifier of the created Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The name of the Robot
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotCreateOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotCreateOutput: required")
	}
	type Plain ToolRobotCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotCreateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotCreate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotCreate: required")
	}
	type Plain ToolRobotCreate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotCreate(plain)
	return nil
}

// Delete a Robot permanently.
type ToolRobotDelete struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotDeleteInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotDeleteOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolRobotDeleteInput struct {
	// The unique identifier of the Robot to delete. Must be a valid XID format (20
	// character alphanumeric string).
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDeleteInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotDeleteInput: required")
	}
	type Plain ToolRobotDeleteInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotDeleteInput(plain)
	return nil
}

type ToolRobotDeleteOutput struct {
	// The ID of the deleted Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Whether the deletion was successful
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDeleteOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotDeleteOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ToolRobotDeleteOutput: required")
	}
	type Plain ToolRobotDeleteOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotDeleteOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDelete) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotDelete: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotDelete: required")
	}
	type Plain ToolRobotDelete
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotDelete(plain)
	return nil
}

// Get details of a specific Robot by its ID. Use this to view the full
// configuration of a Robot.
type ToolRobotGet struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// Get a list of all available tool names and their descriptions. This is useful
// when creating or updating a Robot to know what tools are available without
// loading full schemas. Returns a lightweight list of tool names and brief
// descriptions.
type ToolRobotGetAllToolNames struct {
	// Input corresponds to the JSON schema field "input".
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotGetAllToolNamesOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// List of all available tools with their names and descriptions
type ToolRobotGetAllToolNamesOutput []ToolInfo

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetAllToolNames) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotGetAllToolNames: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotGetAllToolNames: required")
	}
	type Plain ToolRobotGetAllToolNames
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotGetAllToolNames(plain)
	return nil
}

type ToolRobotGetInput struct {
	// The unique identifier of the Robot to retrieve. Must be a valid XID format (20
	// character alphanumeric string). Example: cq3pqt0q91s73dq8r000
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotGetInput: required")
	}
	type Plain ToolRobotGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotGetInput(plain)
	return nil
}

type ToolRobotGetOutput struct {
	// Human-readable description of the Robot's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The name of the Robot
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The Robot's directive
	Playbook string `json:"playbook" yaml:"playbook" mapstructure:"playbook"`

	// List of tool names that the Robot can use
	Tools []string `json:"tools" yaml:"tools" mapstructure:"tools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotGetOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotGetOutput: required")
	}
	if _, ok := raw["playbook"]; raw != nil && !ok {
		return fmt.Errorf("field playbook in ToolRobotGetOutput: required")
	}
	if _, ok := raw["tools"]; raw != nil && !ok {
		return fmt.Errorf("field tools in ToolRobotGetOutput: required")
	}
	type Plain ToolRobotGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotGetOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGet) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotGet: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotGet: required")
	}
	type Plain ToolRobotGet
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotGet(plain)
	return nil
}

// List all available Robots. Use this to see what Robots have been created and
// what they do.
type ToolRobotList struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolRobotListInput struct {
	// Maximum number of Robots to return (default 20)
	Limit *int `json:"limit,omitempty" yaml:"limit,omitempty" mapstructure:"limit,omitempty"`
}

type ToolRobotListOutput struct {
	// List of Robots
	Robots []RobotItem `json:"robots" yaml:"robots" mapstructure:"robots"`

	// Total number of Robots found
	Total int `json:"total" yaml:"total" mapstructure:"total"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robots"]; raw != nil && !ok {
		return fmt.Errorf("field robots in ToolRobotListOutput: required")
	}
	if _, ok := raw["total"]; raw != nil && !ok {
		return fmt.Errorf("field total in ToolRobotListOutput: required")
	}
	type Plain ToolRobotListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotListOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotList) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotList: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotList: required")
	}
	type Plain ToolRobotList
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotList(plain)
	return nil
}

// Switch the current conversation to a different Robot (agent). Use this when the
// user wants to talk to a different specialized agent or when a different agent
// would be better suited to help with the user's request.
type ToolRobotSwitch struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotSwitchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotSwitchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolRobotSwitchInput struct {
	// The ID of the Robot (agent) to switch to. Must be a valid XID format (20
	// character alphanumeric string). Use robot_list to see available Robot IDs.
	RobotId string `json:"robot_id" yaml:"robot_id" mapstructure:"robot_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robot_id"]; raw != nil && !ok {
		return fmt.Errorf("field robot_id in ToolRobotSwitchInput: required")
	}
	type Plain ToolRobotSwitchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.RobotId)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "RobotId", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotSwitchInput(plain)
	return nil
}

type ToolRobotSwitchOutput struct {
	// The ID of the robot that was switched to
	RobotId string `json:"robot_id" yaml:"robot_id" mapstructure:"robot_id"`

	// Whether the agent switch was successful
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robot_id"]; raw != nil && !ok {
		return fmt.Errorf("field robot_id in ToolRobotSwitchOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ToolRobotSwitchOutput: required")
	}
	type Plain ToolRobotSwitchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotSwitchOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitch) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotSwitch: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotSwitch: required")
	}
	type Plain ToolRobotSwitch
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotSwitch(plain)
	return nil
}

// Update a Robot's configuration. You can modify its name, description, playbook
// (directive), or tools. Only provide the fields you want to change.
type ToolRobotUpdate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolRobotUpdateInput struct {
	// The new description for the Robot
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the Robot to update. Must be a valid XID format (20
	// character alphanumeric string).
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The new name for the Robot
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The new directive/system prompt for the Robot
	Playbook *string `json:"playbook,omitempty" yaml:"playbook,omitempty" mapstructure:"playbook,omitempty"`

	// The new list of tool names that the Robot can use.
	Tools []string `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotUpdateInput: required")
	}
	type Plain ToolRobotUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	if plain.Name != nil && len(*plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if plain.Playbook != nil && len(*plain.Playbook) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "playbook", 1)
	}
	*j = ToolRobotUpdateInput(plain)
	return nil
}

type ToolRobotUpdateOutput struct {
	// The unique identifier of the updated Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The Robot's name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotUpdateOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotUpdateOutput: required")
	}
	type Plain ToolRobotUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotUpdateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotUpdate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotUpdate: required")
	}
	type Plain ToolRobotUpdate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotUpdate(plain)
	return nil
}

// Search the Storyden knowledge base for library pages, forum threads, and other
// content. Returns relevant results matching the query.
type ToolSearch struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolSearchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolSearchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolSearchInput struct {
	// Filter by author handles (usernames). Author handles that don't exist will be
	// reported in the error message while still searching with valid authors. Do not
	// use '@' prefix.
	Authors []string `json:"authors,omitempty" yaml:"authors,omitempty" mapstructure:"authors,omitempty"`

	// Filter by category names (for forum threads). Category names are
	// case-insensitive. Categories that don't exist will be reported in the error
	// message while still searching with valid categories.
	Categories []string `json:"categories,omitempty" yaml:"categories,omitempty" mapstructure:"categories,omitempty"`

	// Filter by content types.
	Kind []DatagraphItemKindYaml `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Maximum number of results to return (default 10, max 100)
	MaxResults *int `json:"max_results,omitempty" yaml:"max_results,omitempty" mapstructure:"max_results,omitempty"`

	// The search query text
	Query string `json:"query" yaml:"query" mapstructure:"query"`

	// Filter by tag names. Tags are case-sensitive.
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in ToolSearchInput: required")
	}
	type Plain ToolSearchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MaxResults != nil && 100 < *plain.MaxResults {
		return fmt.Errorf("field %s: must be <= %v", "max_results", 100)
	}
	if plain.MaxResults != nil && 1 > *plain.MaxResults {
		return fmt.Errorf("field %s: must be >= %v", "max_results", 1)
	}
	if len(plain.Query) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "query", 1)
	}
	*j = ToolSearchInput(plain)
	return nil
}

type ToolSearchOutput struct {
	// List of search results
	Items []SearchedItem `json:"items" yaml:"items" mapstructure:"items"`

	// Total number of results found
	Results int `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in ToolSearchOutput: required")
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in ToolSearchOutput: required")
	}
	type Plain ToolSearchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSearchOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearch) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolSearch: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolSearch: required")
	}
	type Plain ToolSearch
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSearch(plain)
	return nil
}

// Get a list of all tags on the site or search for tags by name. Tags are labels
// used to categorize and organize content. Each tag includes its name and the
// number of items tagged with it.
type ToolTagList struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolTagListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolTagListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolTagListInput struct {
	// Optional search query to filter tags by name. If not provided, returns all
	// tags.
	Query *string `json:"query,omitempty" yaml:"query,omitempty" mapstructure:"query,omitempty"`
}

type ToolTagListOutput struct {
	// List of tags
	Tags []TagItem `json:"tags" yaml:"tags" mapstructure:"tags"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolTagListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolTagListOutput: required")
	}
	type Plain ToolTagListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolTagListOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolTagList) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolTagList: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolTagList: required")
	}
	type Plain ToolTagList
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolTagList(plain)
	return nil
}

// Create a new discussion thread in the forum. Threads are discussions organized
// by category with tags for better discovery.
type ToolThreadCreate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolThreadCreateInput struct {
	// The content of the thread in HTML format
	Body string `json:"body" yaml:"body" mapstructure:"body"`

	// The category slug for the thread. Use category_list to see available
	// categories.
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Optional tags for the thread
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The title of the thread
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Optional URL if this thread is about a specific link
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility (default: published)
	Visibility *ToolThreadCreateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadCreateInputVisibility string

const ToolThreadCreateInputVisibilityDraft ToolThreadCreateInputVisibility = "draft"
const ToolThreadCreateInputVisibilityPublished ToolThreadCreateInputVisibility = "published"

var enumValues_ToolThreadCreateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadCreateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadCreateInputVisibility, v)
	}
	*j = ToolThreadCreateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["body"]; raw != nil && !ok {
		return fmt.Errorf("field body in ToolThreadCreateInput: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ToolThreadCreateInput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadCreateInput: required")
	}
	type Plain ToolThreadCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Title) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "title", 1)
	}
	*j = ToolThreadCreateInput(plain)
	return nil
}

type ToolThreadCreateOutput struct {
	// Author handle
	Author *string `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// Category name
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Thread content as plain text
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Creation timestamp
	CreatedAt *string `json:"created_at,omitempty" yaml:"created_at,omitempty" mapstructure:"created_at,omitempty"`

	// The thread slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The thread title
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility
	Visibility *string `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadCreateOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadCreateOutput: required")
	}
	type Plain ToolThreadCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadCreateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadCreate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadCreate: required")
	}
	type Plain ToolThreadCreate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadCreate(plain)
	return nil
}

// Get a specific thread with its content. Returns the thread details including
// author, content, and category information.
type ToolThreadGet struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolThreadGetInput struct {
	// The unique identifier of the thread to retrieve
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Page number for replies (default: 1)
	Page *int `json:"page,omitempty" yaml:"page,omitempty" mapstructure:"page,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadGetInput: required")
	}
	type Plain ToolThreadGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.Page != nil && 1 > *plain.Page {
		return fmt.Errorf("field %s: must be >= %v", "page", 1)
	}
	*j = ToolThreadGetInput(plain)
	return nil
}

type ToolThreadGetOutput struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Category name
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Thread content as plain text
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Creation timestamp
	CreatedAt string `json:"created_at" yaml:"created_at" mapstructure:"created_at"`

	// Slug corresponds to the JSON schema field "slug".
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags" yaml:"tags" mapstructure:"tags"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Visibility corresponds to the JSON schema field "visibility".
	Visibility string `json:"visibility" yaml:"visibility" mapstructure:"visibility"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ToolThreadGetOutput: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ToolThreadGetOutput: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ToolThreadGetOutput: required")
	}
	if _, ok := raw["created_at"]; raw != nil && !ok {
		return fmt.Errorf("field created_at in ToolThreadGetOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadGetOutput: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolThreadGetOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadGetOutput: required")
	}
	if _, ok := raw["visibility"]; raw != nil && !ok {
		return fmt.Errorf("field visibility in ToolThreadGetOutput: required")
	}
	type Plain ToolThreadGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadGetOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGet) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadGet: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadGet: required")
	}
	type Plain ToolThreadGet
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadGet(plain)
	return nil
}

// List and search discussion threads with filtering and pagination.
type ToolThreadList struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolThreadListInput struct {
	// Page number (default: 1)
	Page *int `json:"page,omitempty" yaml:"page,omitempty" mapstructure:"page,omitempty"`

	// Search query to filter threads
	Query *string `json:"query,omitempty" yaml:"query,omitempty" mapstructure:"query,omitempty"`

	// Filter by visibility
	Visibility *ToolThreadListInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadListInputVisibility string

const ToolThreadListInputVisibilityDraft ToolThreadListInputVisibility = "draft"
const ToolThreadListInputVisibilityPublished ToolThreadListInputVisibility = "published"

var enumValues_ToolThreadListInputVisibility = []interface{}{
	"draft",
	"published",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadListInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadListInputVisibility, v)
	}
	*j = ToolThreadListInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListInput) UnmarshalJSON(value []byte) error {
	type Plain ToolThreadListInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Page != nil && 1 > *plain.Page {
		return fmt.Errorf("field %s: must be >= %v", "page", 1)
	}
	*j = ToolThreadListInput(plain)
	return nil
}

type ToolThreadListOutput struct {
	// CurrentPage corresponds to the JSON schema field "current_page".
	CurrentPage int `json:"current_page" yaml:"current_page" mapstructure:"current_page"`

	// Next page number if available
	NextPage *int `json:"next_page,omitempty" yaml:"next_page,omitempty" mapstructure:"next_page,omitempty"`

	// Threads corresponds to the JSON schema field "threads".
	Threads []ThreadSummary `json:"threads" yaml:"threads" mapstructure:"threads"`

	// TotalPages corresponds to the JSON schema field "total_pages".
	TotalPages int `json:"total_pages" yaml:"total_pages" mapstructure:"total_pages"`

	// TotalResults corresponds to the JSON schema field "total_results".
	TotalResults int `json:"total_results" yaml:"total_results" mapstructure:"total_results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["current_page"]; raw != nil && !ok {
		return fmt.Errorf("field current_page in ToolThreadListOutput: required")
	}
	if _, ok := raw["threads"]; raw != nil && !ok {
		return fmt.Errorf("field threads in ToolThreadListOutput: required")
	}
	if _, ok := raw["total_pages"]; raw != nil && !ok {
		return fmt.Errorf("field total_pages in ToolThreadListOutput: required")
	}
	if _, ok := raw["total_results"]; raw != nil && !ok {
		return fmt.Errorf("field total_results in ToolThreadListOutput: required")
	}
	type Plain ToolThreadListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadListOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadList) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadList: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadList: required")
	}
	type Plain ToolThreadList
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadList(plain)
	return nil
}

// Add a reply to an existing thread
type ToolThreadReply struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadReplyInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadReplyOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolThreadReplyInput struct {
	// The reply content in HTML format
	Body string `json:"body" yaml:"body" mapstructure:"body"`

	// The unique identifier of the thread to reply to
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReplyInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["body"]; raw != nil && !ok {
		return fmt.Errorf("field body in ToolThreadReplyInput: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadReplyInput: required")
	}
	type Plain ToolThreadReplyInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolThreadReplyInput(plain)
	return nil
}

type ToolThreadReplyOutput struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Reply content as plain text
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Creation timestamp
	CreatedAt string `json:"created_at" yaml:"created_at" mapstructure:"created_at"`

	// Update timestamp
	UpdatedAt string `json:"updated_at" yaml:"updated_at" mapstructure:"updated_at"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReplyOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["created_at"]; raw != nil && !ok {
		return fmt.Errorf("field created_at in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["updated_at"]; raw != nil && !ok {
		return fmt.Errorf("field updated_at in ToolThreadReplyOutput: required")
	}
	type Plain ToolThreadReplyOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadReplyOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReply) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadReply: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadReply: required")
	}
	type Plain ToolThreadReply
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadReply(plain)
	return nil
}

// Update an existing thread's properties
type ToolThreadUpdate struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

type ToolThreadUpdateInput struct {
	// New content for the thread in HTML format
	Body *string `json:"body,omitempty" yaml:"body,omitempty" mapstructure:"body,omitempty"`

	// The unique identifier of the thread to update
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// New tags for the thread
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// New title for the thread
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// New visibility: published or draft
	Visibility *ToolThreadUpdateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadUpdateInputVisibility string

const ToolThreadUpdateInputVisibilityDraft ToolThreadUpdateInputVisibility = "draft"
const ToolThreadUpdateInputVisibilityPublished ToolThreadUpdateInputVisibility = "published"

var enumValues_ToolThreadUpdateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadUpdateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadUpdateInputVisibility, v)
	}
	*j = ToolThreadUpdateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadUpdateInput: required")
	}
	type Plain ToolThreadUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Body != nil && len(*plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolThreadUpdateInput(plain)
	return nil
}

type ToolThreadUpdateOutput struct {
	// Author handle
	Author *string `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// Category name
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Thread content as plain text
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Creation timestamp
	CreatedAt *string `json:"created_at,omitempty" yaml:"created_at,omitempty" mapstructure:"created_at,omitempty"`

	// The thread slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The thread title
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility
	Visibility *string `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadUpdateOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadUpdateOutput: required")
	}
	type Plain ToolThreadUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadUpdateOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadUpdate: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadUpdate: required")
	}
	type Plain ToolThreadUpdate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadUpdate(plain)
	return nil
}
